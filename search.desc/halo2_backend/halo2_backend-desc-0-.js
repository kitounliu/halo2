searchState.loadedDescShard("halo2_backend", 0, "This module provides common utilities, traits and …\nThis module provides an implementation of a variant of …\nContains utilities for performing arithmetic over …\nThis module contains utilities and traits for dealing with …\nThe affine version of the curve\nThe base field over which this elliptic curve is …\nThe base field over which this elliptic curve is …\nCURVE_ID used for hash-to-curve.\nThis trait is the affine counterpart to <code>Curve</code> and is used …\nThis trait is a common interface for dealing with elements …\nThe projective form of the curve\nThis trait represents an element of a field.\nThe one element of the field, the multiplicative identity.\nThe scalar field of this elliptic curve.\nThe scalar field of this elliptic curve.\nThe zero element of the field, the additive identity.\nReturns the curve constant a.\nReturns the curve constant $a$.\nReturns the curve constant b.\nReturns the curve constant $b$.\nGets the coordinates of this point.\nCubes this element.\nDoubles this element.\nApply the curve endomorphism by multiplying the …\nObtains a point given $(x, y)$, failing if it is not on the\nRequests a hasher that accepts messages and returns …\nComputes the multiplicative inverse of this element, …\nReturns whether or not this element is on the curve; should\nReturns whether or not this element is on the curve; should\nReturns true iff this element is zero.\nReturns true iff this element is zero.\nReturn the Jacobian coordinates of this point.\nObtains a point given Jacobian coordinates $X : Y : Z$, …\nThis utility function will parallelize an operation that …\nExponentiates <code>self</code> by <code>exp</code>, where <code>exp</code> is a little-endian …\nExponentiates <code>self</code> by <code>exp</code>, where <code>exp</code> is a little-endian …\nReturns an element chosen uniformly at random using a …\nReturns the square root of the field element, if it is …\nEquivalent to <code>Self::sqrt_ratio(self, one())</code>.\nComputes:\nSquares this element.\nCurve elements are serialized in compressed form. Field …\nCurve elements are serialized in uncompressed form. Field …\nSerialization is the same as <code>RawBytes</code>, but no checks are …\nThis enum specifies how various types are serialized and …\nByte length of an affine curve element according to <code>format</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReads a compressed element from the buffer and attempts to …\nReads an element from the buffer and parses it according …\nReads a field element as bytes from the buffer according …\nWrites a curve element according to <code>format</code>:\nWrites a field element as bytes to the buffer according to …\nAn iterator that supports “random access” to its data, …\n<code>IntoParallelIterator</code> implements the conversion to a …\n<code>IntoParallelRefIterator</code> implements the conversion to a …\n<code>IntoParallelRefMutIterator</code> implements the conversion to a …\nThe type of item that the parallel iterator will produce.\nThe type of item that the parallel iterator will produce. …\nThe type of item that will be produced; this is typically …\nThe type of item that this parallel iterator produces. For …\nThe parallel iterator type that will be created.\nThe type of the parallel iterator that will be returned.\nThe type of iterator that will be created.\nParallel version of the standard iterator trait.\nParallel extensions for mutable slices.\nRepresents a fork-join scope which can be used to spawn …\nTests that every item in the parallel iterator matches the …\nSearches for <strong>some</strong> item in the parallel iterator that …\nReturns a plain mutable slice, which is used to implement …\nDivides an iterator into sequential blocks of …\nDivides an iterator into sequential blocks of the given …\nTakes two iterators and creates a new iterator over both.\nSplits an iterator up into fixed-size chunks.\nCreates an iterator which clones all of its elements.  …\nLexicographically compares the elements of this …\nCreates a fresh collection containing all the elements …\nCollects the results of the iterator into the specified …\nCollects this iterator into a linked list of vectors.\nCreates an iterator which copies all of its elements.  …\nCounts the number of items in this parallel iterator.\nReturns the number of threads in the current registry. If …\nInternal method used to define the behavior of this …\nInternal method used to define the behavior of this …\nYields an index along with each item.\nDetermines if the elements of this <code>ParallelIterator</code> are …\nApplies <code>filter_op</code> to each item of this iterator, producing …\nApplies <code>filter_op</code> to each item of this iterator to get an …\nSearches for <strong>some</strong> item in the parallel iterator that …\nSearches for the sequentially <strong>first</strong> item in the parallel …\nSearches for the sequentially <strong>last</strong> item in the parallel …\nApplies the given predicate to the items in the parallel …\nApplies the given predicate to the items in the parallel …\nApplies the given predicate to the items in the parallel …\nApplies <code>map_op</code> to each item of this iterator to get nested …\nApplies <code>map_op</code> to each item of this iterator to get nested …\nAn adaptor that flattens parallel-iterable <code>Item</code>s into one …\nAn adaptor that flattens serial-iterable <code>Item</code>s into one …\nParallel fold is similar to sequential fold except that the\nSplits an iterator into fixed-size chunks, performing a …\nSplits an iterator into fixed-size chunks, performing a …\nApplies <code>fold_op</code> to the given <code>init</code> value with each item of …\nExecutes <code>OP</code> on each item produced by the iterator, in …\nExecutes <code>OP</code> on a value returned by <code>init</code> with each item …\nExecutes <code>OP</code> on the given <code>init</code> value with each item …\nReturns the argument unchanged.\nDetermines if the elements of this <code>ParallelIterator</code> are …\nDetermines if the elements of this <code>ParallelIterator</code> are …\nApplies <code>inspect_op</code> to a reference to each item of this …\nInterleaves elements of this iterator and the other given …\nInterleaves elements of this iterator and the other given …\nIntersperses clones of an element between items of this …\nCalls <code>U::from(self)</code>.\nConverts <code>self</code> into a parallel iterator.\nTakes two closures and <em>potentially</em> runs them in parallel. …\nDetermines if the elements of this <code>ParallelIterator</code> are …\nProduces an exact count of how many items this iterator …\nDetermines if the elements of this <code>ParallelIterator</code> are …\nApplies <code>map_op</code> to each item of this iterator, producing a …\nApplies <code>map_op</code> to a value returned by <code>init</code> with each item …\nApplies <code>map_op</code> to the given <code>init</code> value with each item of …\nComputes the maximum of all the items in the iterator. If …\nComputes the maximum of all the items in the iterator with …\nComputes the item that yields the maximum value for the …\nComputes the minimum of all the items in the iterator. If …\nComputes the minimum of all the items in the iterator with …\nComputes the item that yields the minimum value for the …\nDetermines if the elements of this <code>ParallelIterator</code> are …\nInternal method used to define the behavior of this …\nWraps an iterator with a fuse in case of panics, to halt …\nReturns a parallel iterator over the slice producing …\nReturns a parallel iterator over <code>chunk_size</code> elements of …\nReturns a parallel iterator over at most <code>chunk_size</code> …\nConverts <code>self</code> into a parallel iterator.\nCreates the parallel iterator from <code>self</code>.\nReturns a parallel iterator over <code>chunk_size</code> elements of …\nReturns a parallel iterator over at most <code>chunk_size</code> …\nSorts the slice in parallel.\nSorts the slice in parallel with a comparator function.\nSorts the slice in parallel with a key extraction function.\nSorts the slice in parallel with a key extraction function.\nSorts the slice in parallel, but might not preserve the …\nSorts the slice in parallel with a comparator function, …\nSorts the slice in parallel with a key extraction …\nReturns a parallel iterator over mutable subslices …\nReturns a parallel iterator over mutable subslices …\nLexicographically compares the elements of this …\nPartitions the items of a parallel iterator into a pair of …\nPartitions and maps the items of a parallel iterator into …\nSearches for <strong>some</strong> item in the parallel iterator that …\nSearches for the sequentially <strong>first</strong> item in the parallel …\nSearches for the sequentially <strong>last</strong> item in the parallel …\nSearches for items in the parallel iterator that match the …\nMultiplies all the items in the iterator.\nReduces the items in the iterator into one item using <code>op</code>. …\nReduces the items in the iterator into one item using <code>op</code>. …\nProduces a new iterator with the elements of this iterator …\nCreates a “fork-join” scope <code>s</code> and invokes the closure …\nCreates an iterator that skips the first <code>n</code> elements.\nCreates an iterator that skips <code>n</code> elements from <em>anywhere</em> in …\nCreates an iterator that skips elements from <em>anywhere</em> in …\nSpawns a job into the fork-join scope <code>self</code>. This job will …\nSpawns a job into every thread of the fork-join scope <code>self</code>…\nCreates an iterator that steps by the given amount\nSums up the items in the iterator.\nCreates an iterator that yields the first <code>n</code> elements.\nCreates an iterator that yields <code>n</code> elements from <em>anywhere</em> …\nCreates an iterator that takes elements from <em>anywhere</em> in …\nPerforms a fallible parallel fold.\nImplements <code>iter.try_fold().try_reduce()</code> for …\nPerforms a fallible parallel fold with a cloneable <code>init</code> …\nExecutes a fallible <code>OP</code> on each item produced by the …\nExecutes a fallible <code>OP</code> on a value returned by <code>init</code> with …\nExecutes a fallible <code>OP</code> on the given <code>init</code> value with each …\nReduces the items in the iterator into one item using a …\nReduces the items in the iterator into one item using a …\nUnzips the items of a parallel iterator into a pair of …\nUnzips the results of the iterator into the specified …\nMutates each item of this iterator before yielding it.\nCreates an iterator over the <code>Some</code> items of this iterator, …\nSets the maximum length of iterators desired to process in …\nSets the minimum length of iterators desired to process in …\nInternal method used to define the behavior of this …\nIterates over tuples <code>(A, B)</code>, where the items <code>A</code> are from …\nThe same as <code>Zip</code>, but requires that both iterators have the …\nOut of bounds index passed to a backend\nThe instance sets up a copy constraint involving a column …\nThe constraint system is not satisfied.\nThis is an error that could occur during proving.\nInstance provided exceeds number of available rows\nThe provided instances do not match the circuit parameters.\n<code>k</code> is too small for the given circuit.\nOpening error\nGeneric error not covered by previous cases\nMinimal representation of a verification key that can be …\nThis is a proving key which allows for the creation of …\nTranscript error\nThis is a verifying key which allows for the verification …\nReturns commitments of fixed polynomials\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReads a verification key from a slice of bytes using …\nReads a proving key from a slice of bytes using <code>Self::read</code>.\nGet the underlying <code>EvaluationDomain</code>.\nGet the underlying <code>VerifyingKey</code>.\nHashes a verification key into a transcript.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis module\nConstructs an <code>Error::NotEnoughRowsAvailable</code>.\nObtains a pinned representation of this verification key …\nGenerate a proof\nReads a verification key from a buffer.\nReads a proving key from a buffer. Does so by reading …\nWrites a verifying key to a vector of bytes using …\nWrites a proving key to a vector of bytes using <code>Self::write</code>…\nReturns representative of this <code>VerifyingKey</code> in transcripts\nVerify a plonk proof\nWrites a verifying key to a buffer.\nWrites a proving key to a buffer.\nThe current value of <code>k</code> being used.\nGenerate a <code>ProvingKey</code> from a <code>VerifyingKey</code> and an instance …\nGenerate a <code>VerifyingKey</code> from an instance of <code>CompiledCircuit</code>…\nThe prover object used to create proofs interactively by …\nThe prover object used to create proofs interactively by …\nCommit the <code>witness</code> at <code>phase</code> and return the challenges …\nCommit the <code>witness</code> at <code>phase</code> and return the challenges …\nFinalizes the proof creation.\nFinalizes the proof creation. The following steps are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new prover object\nCreate a new prover object\nCreate a new prover object\nReturns the phases of the circuit\nA verifier that checks multiple proofs in a batch. <strong>This </strong>…\nAdds a proof to the batch.\nFinalizes the batch and checks its validity.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstructs a new batch verifier.\nReturns a boolean indicating whether or not the proof is …\nReturns a boolean indicating whether or not the proof is …\nThe basis over which a polynomial is described.\nThe polynomial is defined as coefficients\nThis is an error that could occur during proving or …\nThis structure contains precomputed constants and other …\nThe polynomial is defined as coefficients of Lagrange …\nGuards is unfinished verification result. Implement this …\nThe polynomial is defined as coefficients of Lagrange …\nMulti scalar engine which is not evaluated yet.\nOpeningProof is not well-formed\nThe output type of this verification strategy after …\nRepresents the minimal parameters that determine an …\nRepresents a univariate polynomial defined over a field …\nCaller needs to re-sample a point\nTrait representing a strategy for verifying Halo 2 proofs.\nObtains a polynomial in coefficient form when given a …\nThis takes us from an n-length coefficient vector into a …\nGeneric commitment scheme structures\nReturns a constant polynomial in the extended Lagrange …\nReturns a constant polynomial in the Lagrange coefficient …\nThis divides the polynomial (in the extended domain) by …\nReturns an empty (zero) polynomial in the coefficient basis\nReturns an empty (zero) polynomial in the extended …\nReturns an empty (zero) polynomial in the Lagrange …\nGet the size of the extended domain\nGet the size of the extended domain\nThis takes us from the extended evaluation domain and gets …\nFinalizes the batch and checks its validity.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the generator of the extended domain’s …\nGet $\\omega$, the generator of the $2^k$ order …\nGet $\\omega^{-1}$, the inverse of the generator of the …\nGets the quotient polynomial’s degree (as a multiple of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInner product argument commitment scheme\nIterate over the values, which are either in coefficient …\nIterate over the values mutably, which are either in …\nGet the size of the domain\nKZG commitment scheme\nComputes evaluations (at the point <code>x</code>, where <code>xn = x^n</code>) of …\nObtains a polynomial in Lagrange form when given a vector …\nThis takes us from an n-length vector into the coefficient …\nCreates new verification strategy instance\nThis constructs a new evaluation domain object based on …\nObtains a polynomial in Lagrange form when given a vector …\nGets the size of this polynomial in terms of the number of …\nObtain a pinned version of this evaluation domain; a …\nObtains an MSM from the verifier strategy and yields back …\nRotates the values in a Lagrange basis polynomial by …\nRotate the extended domain polynomial over the original …\nMultiplies a value by some power of $\\omega$, essentially …\nWrapper type around a blinding factor.\nCan commit to instance or not.\nDefines components of a commitment scheme.\nElliptic curve used to commit the application and witnesses\nUnfinalized verification result. This is returned in …\nMultiscalar multiplication engine\nMultiscalar multiplication engine\nAccumulator for compressed verification\nCommon for Verifier and Prover.\nParameters for circuit synthesis and prover parameters.\nConstant prover parameters\nVerifier specific functionality with circuit constraints\nConstant verifier parameters\nCommon multi-open prover interface for various commitment …\nQuery instance or not\nQuery instance or not\nApplication field of this commitment scheme\nCommon multi-open verifier interface for various …\nAdd another multiexp into this one\nAdd arbitrary term (the scalar and the point)\nReturn base points\nPerform multiexp and check that it results in zero\nThis computes a commitment to a polynomial described by …\nThis commits to a polynomial using its evaluations over …\nCreate a multi-opening proof\nCreate a multi-opening proof\nDownsize <code>Params</code> with smaller <code>k</code>.\nGenerates an empty multiscalar multiplication struct using …\nPerform multiexp and return the result\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLogarithmic size of the circuit\nSize of the circuit\nReturns new instance of parameters\nCreates new prover instance\nCreates new verifier instance\nGiven <code>rng</code> creates new blinding scalar\nWrapper for parameter generator\nReads params from a buffer.\nWrapper for parameter reader\nScalars\nScale all scalars in the MSM by some scaling factor\nProcess the proof and return unfinished result named <code>Guard</code>\nWrites params to a buffer.\nThis module contains an implementation of the polynomial …\nMultiscalar multiplication engines\nIPA multi-open scheme This module contains an optimisation …\nStrategies used with KZG scheme\nConcrete IPA commitment scheme\nPublic parameters for IPA commitment scheme\nVerifier parameters\nThis computes a commitment to a polynomial described by …\nThis commits to a polynomial using its evaluations over …\nCreate a polynomial commitment opening proof for the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitializes parameters for the curve, given a random …\nReads params from a buffer.\nChecks to see if the proof represented within <code>transcript</code> …\nWrites params to a buffer.\nA multiscalar multiplication in the polynomial commitment …\nAdd a value to the first entry of <code>g_scalars</code>.\nAdd another multiexp into this one\nAdd another multiexp into this one\nAdd a vector of scalars to <code>g_scalars</code>. This function will …\nAdd to <code>u_scalar</code>\nAdd to <code>w_scalar</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven verifier parameters Creates an empty multi scalar …\nIPA multi-open prover\nIPA multi-open verifier\nCreate a multi-opening proof\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn accumulator instance consisting of an evaluation claim …\nA verifier that checks multiple proofs in a batch.\nWrapper for verification accumulator\nA verifier that checks single proof\nComputes G = ⟨s, params.g⟩\nFinalizes the batch and checks its validity.\nFinalizes the batch and checks its validity.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe claimed output of the linear-time polycommit opening …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA vector of challenges u_0, …, u_{k - 1} sampled by the …\nLets caller supply the challenges and obtain an MSM with …\nLets caller supply the purported G point and simply appends\nKZG commitment scheme\nMultiscalar multiplication engines\nKZG multi-open scheme\nStrategies used with KZG scheme\nUmbrella commitment scheme construction for all KZG …\nThese are the public parameters for the polynomial …\nParameters KZG-based proof verification:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes parameters for the curve through existing …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads params from a buffer.\nReads params from a buffer.\nReads params from a buffer.\nInitializes parameters for the curve, draws toxic secret …\nWrites params to a buffer.\nWrites params to a buffer.\nWrites parameters to buffer\nTwo channel MSM accumulator\nA multiscalar multiplication in the polynomial commitment …\nAdd another multiexp into this one\nPerforms final pairing check with given verifier params …\nPrepares all scalars in the MSM to linear combination\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an empty MSM instance\nCreate a new two channel MSM accumulator instance\nScale all scalars in the MSM by some scaling factor\nConcrete KZG prover with GWC variant\nConcrete KZG prover with SHPLONK variant\nConcrete KZG verifier with GWC variant\nConcrete KZG multiopen verifier with SHPLONK variant\nCreate a multi-opening proof\nCreate a multi-opening proof\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven parameters creates new prover instance\nVerify a multi-opening proof\nA verifier that checks multiple proofs in a batch\nWrapper for linear verification accumulator\nA verifier that checks a single proof\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs an empty batch verifier\nConstructs an empty batch verifier\nConstructs and initialized new batch verifier\nWe will replace BLAKE2b with an algebraic hash function in …\nWe will replace BLAKE2b with an algebraic hash function in …\nA 255-bit challenge.\nThe scalar representation of a verifier challenge.\n<code>EncodedChallenge&lt;C&gt;</code> defines a challenge encoding with a …\nThe Input type used to derive the challenge encoding. For …\nKeccak256 hash function reader for EVM compatibility\nKeccak256 hash function writer for EVM compatibility\nGeneric transcript view (from either the prover or verifier…\nTranscript view from the perspective of a verifier that …\nInitializes transcript at verifier side.\nTranscript view from the perspective of a prover that has …\nManages beginning and finishing of transcript pipeline.\nCast an encoded challenge as a typed <code>ChallengeScalar</code>.\nWriting the point to the transcript without writing it to …\nWriting the scalar to the transcript without writing it to …\nConclude the interaction and return the output buffer …\nConclude the interaction and return the output buffer …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a scalar field element from an encoded challenge.\nInitialize a transcript given an input buffer.\nInitialize a transcript given an output buffer.\nInitialize a transcript given an input buffer.\nInitialize a transcript given an input buffer.\nInitialize a transcript given an output buffer.\nInitialize a transcript given an output buffer.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet an encoded challenge from a given input challenge.\nRead a curve point from the prover.\nRead a curve scalar from the prover.\nSqueeze an encoded verifier challenge from the transcript.\nSqueeze a typed challenge (in the scalar field) from the …\nWrite a curve point to the proof and the transcript.\nWrite a scalar to the proof and the transcript.")